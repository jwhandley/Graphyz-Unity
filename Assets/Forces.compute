#pragma kernel NodeForce
#pragma kernel Integration

struct Node
{
    uint id;
    float2 position;
    float2 lastPosition;
    float2 acceleration;
    uint inDegree;
    uint outDegree;
};

RWStructuredBuffer<Node> Nodes;
RWStructuredBuffer<uint> InAdjacency;
RWStructuredBuffer<uint> OutAdjacency;
RWStructuredBuffer<uint> InOffsets;
RWStructuredBuffer<uint> OutOffsets;

uint nodeCount;
float deltaTime;
float minDistance;
float gravity;
float repulsionStrength;
float damping;
float minLength;

[numthreads(256,1,1)]
void NodeForce (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;

    if (index >= nodeCount)
    {
        return;
    }

    Node node = Nodes[index];

    // Gravity
    node.acceleration -= gravity * node.position / length(node.position) * (node.outDegree+node.inDegree+1);
    GroupMemoryBarrierWithGroupSync();

    // Repulsion force
    for (uint i = 0; i < nodeCount; ++i)
    {
        if (i == index) continue;

        Node neighbor = Nodes[i];
        float2 disp = node.position - neighbor.position;
        float dist = dot(disp, disp);
        dist = dist < minDistance ? minDistance : dist;
        
        float2 repulsionForce = disp / length(disp) * repulsionStrength / dist * (node.outDegree+node.inDegree+1) * (neighbor.outDegree+neighbor.inDegree+1);
        node.acceleration += repulsionForce;
          
    }
    GroupMemoryBarrierWithGroupSync();

    // Attraction forces
    for (uint j = 0; j < node.inDegree; ++j)
    {
        uint nbr = InAdjacency[InOffsets[index] + j];
        Node neighbor = Nodes[nbr];

        float2 disp = node.position - neighbor.position;
        
        node.acceleration -= disp;
    }
    GroupMemoryBarrierWithGroupSync();

    for (uint k = 0; k < node.outDegree; ++k)
    {
        uint nbr = OutAdjacency[OutOffsets[index] + k];
        Node neighbor = Nodes[nbr];

        float2 disp = neighbor.position - node.position;
        
        node.acceleration += disp;
    }
    GroupMemoryBarrierWithGroupSync();

    Nodes[index] = node;
}

[numthreads(256,1,1)]
void Integration (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;

    if (index >= nodeCount)
    {
        return;
    }

    Node node = Nodes[index];

    // Apply Verlet integration
    float2 velocity = damping * (node.position - node.lastPosition);
    node.lastPosition = node.position;
    node.position += velocity + node.acceleration / (node.inDegree + node.outDegree + 1) * deltaTime * deltaTime;
    node.acceleration = float2(0, 0);

    Nodes[index] = node;
}