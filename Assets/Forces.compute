#pragma kernel NodeForce

struct Node
{
    uint id;
    float2 position;
    float2 velocity;
    uint degree;
};

RWStructuredBuffer<Node> Nodes;
RWStructuredBuffer<uint> Adjacency;
RWStructuredBuffer<uint> Offsets;

uint nodeCount;
float deltaTime;
float gravity;
float repulsionStrength;
float attractionStrength;
float damping;

[numthreads(256,1,1)]
void NodeForce (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;

    if (index >= nodeCount)
    {
        return;
    }

    Node node = Nodes[index];

    float mass = sqrt(node.degree + 1);
    float2 force = float2(0,0);

    // Gravitational force
    force -= gravity * normalize(node.position);

    // Repulsion force
    for (uint i = 0; i < nodeCount; ++i)
    {
        if (i == index) continue;

        Node neighbor = Nodes[i];
        float2 disp = node.position - neighbor.position;
        float dist = length(disp) + 0.001;
        uint massSqr = mass * sqrt(neighbor.degree+1);
        float2 repulsionForce = normalize(disp) * repulsionStrength / (dist * dist);
        force += repulsionForce;
    }
    

    // Attraction forces
    for (uint j = 0; j < node.degree; ++j)
    {
        uint nbr = Adjacency[Offsets[index] + j];
        Node neighbor = Nodes[nbr];

        float2 disp = node.position - neighbor.position;
        force -= attractionStrength * disp;
    }
    
    GroupMemoryBarrierWithGroupSync();
    float2 acceleration = force / sqrt(node.degree+1);
    node.velocity += acceleration;
    node.velocity *= damping;
    node.velocity = clamp(node.velocity, -50, 50);
    node.position += node.velocity * deltaTime;

    Nodes[index] = node;
}