#pragma kernel NodeForce

struct Node
{
    uint id;
    float2 position;
    float2 velocity;
    uint inDegree;
    uint outDegree;
};

RWStructuredBuffer<Node> Nodes;
RWStructuredBuffer<uint> InAdjacency;
RWStructuredBuffer<uint> OutAdjacency;
RWStructuredBuffer<uint> InOffsets;
RWStructuredBuffer<uint> OutOffsets;

uint nodeCount;
float deltaTime;
float gravity;
float repulsionStrength;
float attractionStrength;
float damping;

[numthreads(256,1,1)]
void NodeForce (uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;

    if (index >= nodeCount)
    {
        return;
    }

    Node node = Nodes[index];
    float2 force = float2(0,0);

    force -= gravity * normalize(node.position);

    // Repulsion force
    for (uint i = 0; i < nodeCount; ++i)
    {
        if (i == index) continue;

        Node neighbor = Nodes[i];
        float2 disp = node.position - neighbor.position;
        float dist = length(disp) + 0.001;
        uint massSqr = (neighbor.outDegree+neighbor.inDegree+1) * (node.outDegree + node.inDegree + 1);
        float2 repulsionForce = disp * repulsionStrength * massSqr / pow(dist * dist, 3.0/2.0);
        force += repulsionForce;
    }
    

    // Attraction forces
    for (uint j = 0; j < node.inDegree; ++j)
    {
        uint nbr = InAdjacency[InOffsets[index] + j];
        Node neighbor = Nodes[nbr];

        float2 disp = node.position - neighbor.position;
        force -= attractionStrength * disp;
    }
    

    for (uint k = 0; k < node.outDegree; ++k)
    {
        uint nbr = OutAdjacency[OutOffsets[index] + k];
        Node neighbor = Nodes[nbr];

        float2 disp = node.position - neighbor.position;
        force -= attractionStrength * disp;
    }

    GroupMemoryBarrierWithGroupSync();
    float2 acceleration = force / (node.inDegree + node.outDegree + 1);
    node.velocity += acceleration * deltaTime;
    node.velocity *= damping;
    node.velocity = clamp(node.velocity, -20, 20);
    node.position += node.velocity * deltaTime;

    Nodes[index] = node;
}